import os
import subprocess
import time
import re
import google.generativeai as genai
from dotenv import load_dotenv

load_dotenv()
api_key = os.getenv("GEMINI_API_KEY")
if not api_key:
    print("ERROR: GEMINI_API_KEY is missing in .env file.")
    exit(1)

genai.configure(api_key=api_key)
LOG_FILE = "build.log"
BRANCH_PREFIX = "fix/auto-repair"

MODEL_PRIORITY_LIST = [
    "gemini-2.5-flash",     
    "gemini-2.0-flash-lite", 
    "gemini-2.0-flash",        
    "gemini-2.0-flash-exp"   
]

def read_file(filepath):
    try:
        with open(filepath, "r") as f:
            return f.read()
    except FileNotFoundError:
        return None

def write_file(filepath, content):
    with open(filepath, "w") as f:
        f.write(content)

def run_command(command):
    result = subprocess.run(command, shell=True, capture_output=True, text=True)
    if result.returncode != 0:
        print(f"Warning: Command '{command}' had issues.\n{result.stderr}")
    return result.stdout.strip()

def remove_ansi_codes(text):
    ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
    return ansi_escape.sub('', text)

def detect_broken_file(log_content):
    print(f"DEBUG: Current Working Directory: {os.getcwd()}")
    clean_log = remove_ansi_codes(log_content)
    regex = r"([a-zA-Z0-9_\-\./]+\.(tsx?|jsx?|css|json|py))"
    matches = re.findall(regex, clean_log)
    
    unique_files = set()
    for match in matches:
        raw_path = match[0]
        if os.path.exists(raw_path):
            unique_files.add(raw_path)
        elif os.path.exists(os.path.join("broken-app", raw_path)):
            unique_files.add(os.path.join("broken-app", raw_path))
            
    if unique_files:
        best_candidate = sorted(list(unique_files), key=len)[0]
        print(f"DEBUG: Selected target file: {best_candidate}")
        return best_candidate
    
    print("No valid file found. Please check if 'broken-app' folder exists.")
    return None

def generate_fix(error_log, current_code, target_file):
    prompt = f"""
    You are a Senior DevOps Auto-Fixer Bot.
    
    CONTEXT:
    The build failed due to syntax or logic errors.
    
    ERROR LOGS:
    {error_log}
    
    BROKEN FILE ({target_file}):
    {current_code}
    
    TASK:
    1. Analyze the error log to find the exact syntax error.
    2. Fix the code while preserving the original logic.
    3. CRITICAL: Return ONLY the raw code. Do NOT output markdown backticks (like ```typescript).
    """
    
    for model_name in MODEL_PRIORITY_LIST:
        print(f"AGENT: Connecting to '{model_name}'...")
        try:
            model = genai.GenerativeModel(model_name)
            response = model.generate_content(prompt)
            cleaned_code = response.text
            cleaned_code = cleaned_code.replace("```typescript", "").replace("```tsx", "")
            cleaned_code = cleaned_code.replace("```javascript", "").replace("```js", "")
            cleaned_code = cleaned_code.replace("```", "").strip()
            
            print(f"SUCCESS Fix generated by {model_name}!")
            return cleaned_code
            
        except Exception as e:
            error_str = str(e)
            if "429" in error_str:
                print(f"Rate Limit (429) on {model_name}. Failing over to next model...")
            elif "404" in error_str:
                print(f"Model {model_name} not found. Skipping...")
            else:
                print(f"Error with {model_name}: {e}")
            continue
            
    print("CRITICAL ERROR!!! All AI models failed/exhausted.")
    return None

def git_operations(target_file, branch_name):
    print(f"AGENT: Pushing fix to branch {branch_name}...")
    run_command(f"git checkout -b {branch_name}")
    run_command(f"git add {target_file}")
    run_command(f"git commit -m 'fix: automated repair by Gemini Agent'")
    run_command(f"git push origin {branch_name}")

def main():
    logs = read_file(LOG_FILE)
    if not logs or "error" not in logs.lower():
        print("AGENT: No errors detected in logs.")
        return

    target_file = detect_broken_file(logs)
    if not target_file: return

    code = read_file(target_file)
    fixed_code = generate_fix(logs, code, target_file)
    
    if fixed_code:
        write_file(target_file, fixed_code)
        print(f"AGENT: Applied fix to {target_file}")
        timestamp = int(time.time())
        branch_name = f"{BRANCH_PREFIX}-{timestamp}"
        git_operations(target_file, branch_name)
    else:
        print("AGENT: Could not generate a fix.")

if __name__ == "__main__":
    main()